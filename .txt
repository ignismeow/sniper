The issue you're facing could be related to the way the event listener is set up. In the provided code, the `init` function creates an event filter that listens for new `PairCreated` events from the latest block. However, this approach may not work as expected when running on a local Ethereum node or fork.

To address this issue, we can modify the event listener to listen for events from the beginning of the blockchain. Additionally, we'll move the event listener logic into the main loop to ensure it's continuously checking for new events.

Here's the rewritten code with the necessary changes:

```python
import asyncio
import json
import csv
import time
from web3 import Web3

LOCAL_WSS = 'ws://127.0.0.1:8545'
provider = Web3(Web3.LegacyWebSocketProvider(LOCAL_WSS))

private_key = '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80'
account =  provider.eth.account.from_key(private_key)
wallet_address = account.address
print(wallet_address)

# Load contract ABIs and addresses
with open("blockchain.json") as f:
    blockchain = json.load(f)

factory_contract = provider.eth.contract(
    address=blockchain['factoryAddress'],
    abi=blockchain['factoryAbi']
)

router_contract = provider.eth.contract(
    address=blockchain['routerAddress'],
    abi=blockchain['routerAbi']
)

SNIPE_LIST_FILE = 'snipeList.csv'
TOKEN_LIST_FILE = 'tokenList.csv'

# Function to handle sniping
async def snipe():
    print('Snipe loop')
    with open(SNIPE_LIST_FILE, 'r') as f:
        reader = csv.reader(f)
        snipe_list = list(reader)

    if not snipe_list:
        return

    for snipe in snipe_list:
        pair_address, weth_address, token_address = snipe
        print(f"Trying to snipe {token_address} on {pair_address}")

        pair_contract = provider.eth.contract(
            address=pair_address,
            abi=blockchain['pairAbi']
        )
        total_supply = pair_contract.functions.totalSupply().call()
        if total_supply == 0:
            print(f"Pair {pair_address} is empty, skipping...")
            continue

        token_in = weth_address
        token_out = token_address

        amount_in = Web3.to_wei(0.1, 'ether')
        amounts_out = router_contract.functions.getAmountsOut(amount_in, [token_in, token_out]).call()

        amount_out_min = amounts_out[1] - (amounts_out[1] * 5 // 100)
        print(f"Buying new token: tokenIn: {amount_in} {token_in} (WETH), tokenOut: {amount_out_min} {token_out}")

        try:
            tx = router_contract.functions.swapTokensForExactTokens(
                amount_in,
                amount_out_min,
                [token_in, token_out],
                blockchain['recipient'],
                int(time.time()) + 1000 * 60 * 10
            ).build_transaction({
                'from': wallet_address,
                'gas': 5000000,
                'gasPrice': provider.to_wei('20', 'gwei'),
                'nonce': provider.eth.get_transaction_count(wallet_address)
            })
            signed_tx = provider.eth.account.sign_transaction(tx, account.key)
            tx_hash = provider.eth.send_raw_transaction(signed_tx.raw_transaction)
            receipt = provider.eth.wait_for_transaction_receipt(tx_hash)
            print(f"Transaction confirmed in block: {receipt.blockNumber}")
        except Exception as e:
            print(f"Transaction failed: {e}")

        # Update snipeList after transaction
        snipe_list =
